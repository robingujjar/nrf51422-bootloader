#include "nrf.h"
#include "nrf_gpio.h"
#include "boards.h"
#include "uartreader.h"
#include "hexparser.h"
#include "simple_uart.h"
#include "dfu_types.h"
#include "nrf_delay.h"


/*Example UART program bin file data= TX= 8,RX=7*/
const uint8_t hexFileArray2[908] = {

	0x08, 0x2C, 0x00, 0x20, 0xD5, 0x00, 0x02, 0x00, 0xE7, 0x00, 0x02, 0x00,
	0xE9, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xED, 0x00, 0x02, 0x00,
	0xEF, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00, 0xF1, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x48, 0x85, 0x46, 0x00, 0xF0, 0x1C, 0xF8, 0x00, 0x48, 0x00, 0x47,
	0x15, 0x02, 0x02, 0x00, 0x08, 0x2C, 0x00, 0x20, 0x07, 0x48, 0x02, 0x68,
	0x0F, 0x21, 0x0A, 0x43, 0x02, 0x60, 0x06, 0x48, 0x80, 0x47, 0x06, 0x48,
	0x00, 0x47, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7,
	0xFE, 0xE7, 0x00, 0x00, 0x24, 0x05, 0x00, 0x40, 0x25, 0x01, 0x02, 0x00,
	0xC1, 0x00, 0x02, 0x00, 0x06, 0x4C, 0x01, 0x25, 0x06, 0x4E, 0x05, 0xE0,
	0x20, 0x46, 0xE3, 0x68, 0x07, 0xC8, 0x2B, 0x43, 0x98, 0x47, 0x10, 0x34,
	0xB4, 0x42, 0xF7, 0xD3, 0xFF, 0xF7, 0xD6, 0xFF, 0x78, 0x03, 0x02, 0x00,
	0x88, 0x03, 0x02, 0x00, 0x10, 0xB5, 0x00, 0xF0, 0x43, 0xF8, 0x00, 0x28,
	0x05, 0xD0, 0x07, 0x48, 0x07, 0x49, 0x48, 0x60, 0xC8, 0x13, 0x07, 0x49,
	0x88, 0x61, 0x00, 0xF0, 0x1F, 0xF8, 0x00, 0x28, 0x02, 0xD0, 0x01, 0x20,
	0x04, 0x49, 0x88, 0x60, 0x10, 0xBD, 0x00, 0x00, 0xDF, 0xFF, 0x07, 0xC0,
	0x00, 0x05, 0x00, 0x40, 0x00, 0x6C, 0x00, 0x40, 0x00, 0x06, 0x00, 0x40,
	0x02, 0xE0, 0x08, 0xC8, 0x12, 0x1F, 0x08, 0xC1, 0x00, 0x2A, 0xFA, 0xD1,
	0x70, 0x47, 0x70, 0x47, 0x00, 0x20, 0x01, 0xE0, 0x01, 0xC1, 0x12, 0x1F,
	0x00, 0x2A, 0xFB, 0xD1, 0x70, 0x47, 0x00, 0x00, 0x0B, 0x48, 0x00, 0x8C,
	0xC0, 0xB2, 0x01, 0x28, 0x10, 0xD1, 0x09, 0x48, 0x80, 0x8C, 0x00, 0x07,
	0x00, 0x0F, 0x0B, 0xD1, 0x06, 0x48, 0x80, 0x6A, 0xF0, 0x21, 0x08, 0x40,
	0x40, 0x28, 0x05, 0xD1, 0x03, 0x48, 0xC0, 0x6A, 0x08, 0x42, 0x01, 0xD1,
	0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0xFC, 0xE7, 0xC0, 0x0F, 0x00, 0xF0,
	0x17, 0x48, 0x00, 0x8C, 0xC0, 0xB2, 0x01, 0x28, 0x27, 0xD1, 0x15, 0x48,
	0x80, 0x8C, 0x00, 0x07, 0x00, 0x0F, 0x22, 0xD1, 0x12, 0x48, 0x80, 0x6A,
	0xF0, 0x21, 0x08, 0x42, 0x05, 0xD1, 0x10, 0x48, 0xC0, 0x6A, 0x08, 0x42,
	0x01, 0xD1, 0x01, 0x20, 0x70, 0x47, 0x0D, 0x48, 0x80, 0x6A, 0xF0, 0x21,
	0x08, 0x40, 0x10, 0x28, 0x05, 0xD1, 0x0A, 0x48, 0xC0, 0x6A, 0x08, 0x42,
	0x01, 0xD1, 0x01, 0x20, 0xF2, 0xE7, 0x07, 0x48, 0x80, 0x6A, 0xF0, 0x21,
	0x08, 0x40, 0x30, 0x28, 0x05, 0xD1, 0x04, 0x48, 0xC0, 0x6A, 0x08, 0x42,
	0x01, 0xD1, 0x01, 0x20, 0xE6, 0xE7, 0x00, 0x20, 0xE4, 0xE7, 0x00, 0x00,
	0xC0, 0x0F, 0x00, 0xF0, 0x08, 0xB5, 0x00, 0x20, 0x07, 0x23, 0x12, 0x22,
	0x08, 0x21, 0x00, 0x90, 0x13, 0x20, 0x00, 0xF0, 0x43, 0xF8, 0x08, 0x20,
	0x01, 0x21, 0x05, 0x22, 0x12, 0x07, 0x07, 0x23, 0x1B, 0x02, 0xD2, 0x18,
	0x83, 0x00, 0xD1, 0x50, 0x00, 0xBF, 0x00, 0xBF, 0x0B, 0xA0, 0x00, 0xF0,
	0x8B, 0xF8, 0x00, 0xBF, 0x11, 0xE0, 0x00, 0xF0, 0x67, 0xF8, 0x04, 0x46,
	0x20, 0x46, 0x00, 0xF0, 0x73, 0xF8, 0x71, 0x2C, 0x01, 0xD0, 0x51, 0x2C,
	0x06, 0xD1, 0x00, 0xBF, 0x06, 0xA0, 0x00, 0xF0, 0x7B, 0xF8, 0x00, 0xBF,
	0x00, 0xBF, 0xFE, 0xE7, 0x00, 0xBF, 0xEC, 0xE7, 0x20, 0x0A, 0x0D, 0x53,
	0x74, 0x61, 0x72, 0x74, 0x3A, 0x20, 0x00, 0x00, 0x20, 0x0A, 0x0D, 0x45,
	0x78, 0x69, 0x74, 0x21, 0x0A, 0x0D, 0x00, 0x00, 0x10, 0xB5, 0x8A, 0x00,
	0x05, 0x23, 0x1B, 0x07, 0x07, 0x24, 0x24, 0x02, 0x1B, 0x19, 0x84, 0x00,
	0x1A, 0x51, 0x10, 0xBD, 0x01, 0x21, 0x05, 0x22, 0x12, 0x07, 0x07, 0x23,
	0x1B, 0x02, 0xD2, 0x18, 0x83, 0x00, 0xD1, 0x50, 0x70, 0x47, 0x00, 0x00,
	0xF8, 0xB5, 0x07, 0x46, 0x0C, 0x46, 0x15, 0x46, 0x1E, 0x46, 0x20, 0x46,
	0xFF, 0xF7, 0xEE, 0xFF, 0x00, 0x21, 0x30, 0x46, 0xFF, 0xF7, 0xE0, 0xFF,
	0x10, 0x48, 0xC4, 0x60, 0x46, 0x61, 0x06, 0x98, 0x00, 0x28, 0x0D, 0xD0,
	0x38, 0x46, 0xFF, 0xF7, 0xE1, 0xFF, 0x00, 0x21, 0x28, 0x46, 0xFF, 0xF7,
	0xD3, 0xFF, 0x0A, 0x48, 0x05, 0x61, 0x87, 0x60, 0x01, 0x20, 0x08, 0x49,
	0x40, 0x31, 0xC8, 0x62, 0x07, 0x48, 0x06, 0x49, 0x48, 0x62, 0x04, 0x20,
	0x08, 0x60, 0x01, 0x20, 0x05, 0x49, 0x88, 0x60, 0x08, 0x60, 0x00, 0x20,
	0x04, 0x49, 0x88, 0x60, 0xF8, 0xBD, 0x00, 0x00, 0x00, 0x25, 0x00, 0x40,
	0x00, 0x50, 0x9D, 0x00, 0x00, 0x20, 0x00, 0x40, 0x00, 0x21, 0x00, 0x40,
	0x00, 0xBF, 0x05, 0x48, 0x80, 0x68, 0x01, 0x28, 0xFB, 0xD1, 0x00, 0x20,
	0x02, 0x49, 0x88, 0x60, 0x02, 0x48, 0x80, 0x69, 0xC0, 0xB2, 0x70, 0x47,
	0x00, 0x21, 0x00, 0x40, 0x00, 0x25, 0x00, 0x40, 0x05, 0x49, 0xC8, 0x61,
	0x00, 0xBF, 0x05, 0x49, 0xC9, 0x69, 0x01, 0x29, 0xFB, 0xD1, 0x00, 0x21,
	0x02, 0x4A, 0xD1, 0x61, 0x70, 0x47, 0x00, 0x00, 0x00, 0x25, 0x00, 0x40,
	0x00, 0x21, 0x00, 0x40, 0x30, 0xB5, 0x03, 0x46, 0x00, 0x25, 0x28, 0x46,
	0x6D, 0x1C, 0x1C, 0x5C, 0x05, 0xE0, 0x20, 0x46, 0xFF, 0xF7, 0xE6, 0xFF,
	0x28, 0x46, 0x6D, 0x1C, 0x1C, 0x5C, 0x00, 0x2C, 0xF7, 0xD1, 0x30, 0xBD,
	0x88, 0x03, 0x02, 0x00, 0x00, 0x24, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00,
	0x5C, 0x01, 0x02, 0x00, 0x00, 0x24, 0xF4, 0x00
};

int boot_req = 0;
int mPagesToErase = 0;

int numberOfPagesToErase(void){
	
	return mPagesToErase;
}
int bootloader_request()
{
  return boot_req;
}	

void clear_boot_request(void){
	 boot_req= 0;
}

uint8_t ANT_RequestMessage(uint8_t chan, uint8_t mesg)
{
    
	   switch(mesg){
			      
			 case 0x91:				    
			      boot_req= 0x91;
				    break;
			 case 0x92:
				    boot_req=0x92;
			      mPagesToErase = chan;
			 
				    break;
			 case 0x93:
				    boot_req=0x93;
				    break;
			 case 0x94:
            boot_req=0x94;
				    break;
			 
			 default:
				 
				 break;
				  
		 }
	  
		 return 0;
}

#define APPLICATION_BASE_ADDRESS 0x20000

 /**< Receive buffer provided to the transport layer for receiving data packets. */
static volatile uint32_t  m_receive_packet[PACKET_HEADER_SIZE / sizeof(uint32_t) + PACKET_SIZE / sizeof(uint32_t)];          

static uint32_t  *m_app_write_address; /**< Pointer to the address in flash to write next word of data received. */

static bool  m_bootloader_init_valid = true; /**< Field identifying if a valid data packet has been received. */

static bool  m_flash_prepared = false;       


/*lint -esym(552,m_nrf_start_address) "Symbol not accessed"  */  
/**< Default start address, unless bank 1 is used. 
@note Bank 1 is currently not supported, all applications must be executed from bank 0. */
uint32_t m_nrf_start_address __asm__("NRF_APP_START_ADDRESS") = CODE_REGION_1_START;



volatile bool is_bootloader_running = true;

typedef void (*application_main_t)(void);

void erase_no_of_pages(uint32_t start_page, uint32_t no_of_pages)
{
    uint32_t i;
    uint32_t page_size = NRF_FICR->CODEPAGESIZE;

    NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Een << NVMC_CONFIG_WEN_Pos);
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
    {
        // Do nothing.
    }

    // Erase pages.
    for (i = 0; i < no_of_pages; i++)
    {
        NRF_NVMC->ERASEPAGE = start_page;
        while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
        {
            // Do nothing.
        }
        start_page += page_size;
    }

    // Turn off flash erase enable and wait until the NVMC is ready.
    NRF_NVMC->CONFIG &= ~(NVMC_CONFIG_WEN_Een << NVMC_CONFIG_WEN_Pos);
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
    {
        // Do nothing
    }
}


void write_data(uint32_t * p_start_address, uint32_t * p_data, uint32_t length)
{
    uint32_t index = 0;
    NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos);
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
    {
        // Do nothing.
    }

    for (; index < length;)
    {
			  
        *p_start_address = p_data[index];
			  
        ++p_start_address;
        ++index;
    }

    // Turn off flash write enable and wait until the NVMC is ready.
    NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos);
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
    {
        // Do nothing
    }
}
extern void new_uartreader_send_response(uint8_t rsp );
void start_packet_handle(void)
{
    uint32_t image_size;
    uint32_t no_of_pages;
    uint32_t page_size = NRF_FICR->CODEPAGESIZE;

    image_size = 908;

    no_of_pages = (image_size / page_size) + 1;
	  NRF_UICR->CLENR0 = 0x20000;
	  printf("\n\r page_size = %d, no_of_pages = %d, NRF_UICR->CLENR0 = 0x%x\n\r",page_size,no_of_pages,NRF_UICR->CLENR0);

    //erase_no_of_pages(NRF_UICR->CLENR0, no_of_pages);

    m_app_write_address = (uint32_t *)0x20000;//0x14000;//NRF_UICR->CLENR0;
	  //NRF_UICR->CLENR0 = 0x30000;
    m_flash_prepared    = true;
}


uint32_t temp_data =0 ;
uint8_t k=0;
void data_packet_handle(void)
{
	   uint32_t i = 0;  
    if(m_flash_prepared)
    { 
			  for(i=0; i< 908;i++ ){					
					    switch(k){
								case 0:								
									//temp_data = temp_data| (hexFileArray2[i]<<24);
								   temp_data = temp_data| (hexFileArray2[i]<<0);
								   k++;
									break;
								case 1:	
					        //temp_data = temp_data| (hexFileArray2[i]<<16);
								temp_data = temp_data| (hexFileArray2[i]<<8);
                  k++;							 
									break;
								case 2:	
									//temp_data = temp_data| (hexFileArray2[i]<<8);
								   temp_data = temp_data| (hexFileArray2[i]<<16);
									k++;	
                  /*if(i==2006){
									 //temp_data = temp_data| (0xff<<0);	
                   write_data(m_app_write_address, &temp_data, 1);
                  }*/										
									break;
								case 3:	
									//temp_data = temp_data| (hexFileArray2[i]<<0);
								   temp_data = temp_data| (hexFileArray2[i]<<24);
									if(k==3){
								    k=0;
										nrf_delay_us(10000);
								    write_data(m_app_write_address, &temp_data, 1);
								    temp_data = 0;
								    m_app_write_address += 1;
							    }							 
									break;
								default:
									 break;
							}
							
				}   
    }
    else
    {
        // Ignore, received a data packet without a valid init file or flash has not been prepared.
    }
		i=0;
		uint32_t data =0;
		 m_app_write_address = (uint32_t *)0x20000;//0x14000;//NRF_UICR->CLENR0;
		for(i =0;i<227;i++){
			nrf_delay_us(10000);
			data = *((uint32_t *)m_app_write_address);
			nrf_delay_us(10000);
			printf("\n\r address = 0x%x, data = 0x%x\n\r",m_app_write_address,data);
			nrf_delay_us(10000);
			m_app_write_address+=1;
		}
		printf("\n\r NRF_UICR->CLENR0 = 0x%x\n\r",NRF_UICR->CLENR0);
		printf("\n\r Image flashed done ");
}

void write_firmware_byte(uint32_t data){
	     nrf_delay_us(10);
	     temp_data = data;
	     write_data(m_app_write_address, &temp_data, 1);
			 temp_data = 0;
			 m_app_write_address += 1;
	     //nrf_delay_us(1000);
	
}
static int setup_booloader_environment(void)
{
     start_packet_handle();
     //data_packet_handle(); //This is required for bootloader robin:10/03/2014
	
	  /*uint32_t  n_err_code = sd_softdevice_disable();
     APP_ERROR_CHECK(n_err_code);
	
	   //interrupts_disable();
	
	 my_application_main_t application_main = *(my_application_main_t *)(0x20000+4);
    if (application_main != (my_application_main_t) 0xFFFFFFFF) {
        
			  //(void)sd_softdevice_forward_to_application();
			  //NVIC_SystemReset();
        // Initialize user application's Stack Pointer
        __set_MSP(*(__IO uint32_t*) 0x30000);
        application_main();
			 //StartApplication(0x30000);
        
    } */
	
    return NRF_SUCCESS;       
}

void init(void)
{
    if (NRF_UICR->CLENR0 == 0xFFFFFFFF)
    {
        NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
        NRF_UICR->CLENR0 = 0x20000;
        while (!NRF_NVMC->READY);
        NRF_NVMC->CONFIG = 0;
        NVIC_SystemReset();
    }
}

void erase_app(void)
{
    uint32_t last_page_address = NRF_FICR->CODEPAGESIZE * NRF_FICR->CODESIZE;

    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Een << NVMC_CONFIG_WEN_Pos;

    for (uint32_t address = APPLICATION_BASE_ADDRESS; address < last_page_address; address += NRF_FICR->CODEPAGESIZE)
    {
        NRF_NVMC->ERASEPAGE = address;
        while (!NRF_NVMC->READY);
    }

    NRF_NVMC->CONFIG = 0x0;
}


void nrf51422_erase_app(uint8_t no_of_pages){
	   //new_uartreader_send_response(no_of_pages );
     erase_no_of_pages(NRF_UICR->CLENR0, no_of_pages);
     //new_uartreader_send_response(no_of_pages);	
}

void write_record(uint16_t base_address, hexparser_record * record)
{
    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;

    for (uint32_t i = 0; i < record->byte_count / 4; i++)
    {
        *(uint32_t *) (base_address << 4 | (record->address + (4*i))) = record->data.words[i];
        while (NRF_NVMC->READY & (NVMC_READY_READY_Busy << NVMC_READY_READY_Pos))
        {
        }
    }
    
    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
}

void print_record(uint16_t base_address, hexparser_record * record)
{
	  uint8_t k =0;
	  uint8_t addedlen = 4+record->byte_count;
   
		uint8_t  buf[48];
		
		int i;
		uint8_t chk = 0xa4;
	   

		buf[0] = 0xa4;
		buf[1] = addedlen; chk ^= addedlen;
		buf[2] = 0x91; chk ^= 0x91;
	
		for (i = 0; i < record->byte_count; i++) {
			buf[3+i] = record->data.bytes[i];
			chk ^= record->data.bytes[i];
		}
		
		buf[3+i] = chk;
		
		
		int j=0;
		
		for(j=0;j<4+record->byte_count;j++){
			  
			 //printf("\n %02x \n\r",p_event_message_buffer[j]);
			 app_uart_put(buf[j]);	
			  for(k=0;k<100;k++);	
			  
		}
 
}

uartreader_response_t write_line(uartreader_evt_t * evt)
{
    
    static uint16_t base_address = 0;
    hexparser_record record;
    //hexparser_parse_string((char * ) evt->data, evt->len, &record);
	  hexparser_parse_string(&evt->data[3], evt->data[1], &record);

    if (!hexparser_is_record_valid(&record))
    {
        return FAILURE;
    }

    switch (record.type)
    {
        case EXTENDED_LINEAR_ADDRESS_RECORD:
        case EXTENDED_SEGMENT_ADDRESS_RECORD:
            
            base_address = record.data.words[0];
            break;

        case DATA_RECORD:
            
            write_record(base_address, &record);
				    print_record(base_address, &record);
				    
            break;

        default:
            
            
            break;
    }



    return SUCCESS;
		
		
		
}
/*void uart_handler(uartreader_evt_t * evt)
{
    uartreader_response_t result;
    switch (evt->cmd)
    {
			  //dummy_send_response(evt->cmd );
			
        case ERASE_APP:
            //erase_app();
            uartreader_send_response(SUCCESS);
            break;

        case WRITE_LINE:
            //result = write_line(evt);
            uartreader_send_response(result);
            break;

        case RESET_AND_RUN:
            uartreader_send_response(SUCCESS);
            //NVIC_SystemReset();
            break;

        case NOP:
            uartreader_send_response(SUCCESS);
            break;
    }
}*/
extern void uart_start(void);

int bootloader_main(void)
{
    init();

    /*application_main_t application_main = *(application_main_t *)(APPLICATION_BASE_ADDRESS+4);
    if ((application_main != (application_main_t) 0xFFFFFFFF) && 
        (nrf_gpio_pin_read(BUTTON0) != 0))
    {
        is_bootloader_running = false;
        application_main();
        
    }*/

    is_bootloader_running = true;
	
    setup_booloader_environment();

		return 0;

}
